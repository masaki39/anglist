"""
SagittalMeasureTrain
--------------------
Helper module to export training data for sagittal keypoint models.

Workflow:
- Load a lateral spine X-ray (DICOM volume).
- Place 5 landmarks (L1_ant, L1_post, S1_ant, S1_post, FH) as Markups Fiducials.
- Export an image array (.npy), the source volume (.nrrd), and landmark coordinates
  in IJK (pixel) space (.json) for external model training.
"""

import json
import logging
import os

import qt
import ctk
import slicer
import vtk
import numpy as np
from slicer.ScriptedLoadableModule import (
    ScriptedLoadableModule,
    ScriptedLoadableModuleWidget,
    ScriptedLoadableModuleLogic,
    ScriptedLoadableModuleTest,
)


class SagittalMeasureTrain(ScriptedLoadableModule):
    """Main module class required by Slicer."""

    def __init__(self, parent=None):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "Sagittal Measure Train"
        self.parent.categories = ["Spine"]
        self.parent.dependencies = []
        self.parent.contributors = ["Generated by assistant"]
        self.parent.helpText = (
            "Create training samples for sagittal landmark models. "
            "Load a lateral X-ray volume, place 5 landmarks, and export "
            "image/landmarks to disk for external ML training."
        )
        self.parent.acknowledgementText = "Data export helper for sagittal parameter models."


class SagittalMeasureTrainWidget(ScriptedLoadableModuleWidget):
    """Widget setup and interactions."""

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        self.logic = SagittalMeasureTrainLogic()

        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Training Data Export"
        self.layout.addWidget(parametersCollapsibleButton)

        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        self.volumeSelector = slicer.qMRMLNodeComboBox()
        self.volumeSelector.nodeTypes = ["vtkMRMLScalarVolumeNode"]
        self.volumeSelector.selectNodeUponCreation = True
        self.volumeSelector.addEnabled = False
        self.volumeSelector.removeEnabled = False
        self.volumeSelector.noneEnabled = True
        self.volumeSelector.showHidden = False
        self.volumeSelector.showChildNodeTypes = False
        self.volumeSelector.setMRMLScene(slicer.mrmlScene)
        self.volumeSelector.setToolTip("対象の側面X線Volumeを選択します。")
        parametersFormLayout.addRow("Volume:", self.volumeSelector)

        self.markupSelector = slicer.qMRMLNodeComboBox()
        self.markupSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupSelector.selectNodeUponCreation = True
        self.markupSelector.addEnabled = False
        self.markupSelector.removeEnabled = False
        self.markupSelector.noneEnabled = True
        self.markupSelector.showHidden = False
        self.markupSelector.showChildNodeTypes = False
        self.markupSelector.setMRMLScene(slicer.mrmlScene)
        self.markupSelector.setToolTip("5点のランドマークを配置するMarkups Fiducialを選択/作成します。")
        parametersFormLayout.addRow("Markups:", self.markupSelector)

        self.createMarkupButton = qt.QPushButton("新規作成 / 1点追加")
        self.createMarkupButton.toolTip = "Markupsを作成し、1点だけ配置モードに入ります。次の点もこのボタンで追加してください。"
        parametersFormLayout.addRow("Markups作成:", self.createMarkupButton)

        self.clearMarkupButton = qt.QPushButton("配置点をクリア")
        self.clearMarkupButton.toolTip = "選択中のMarkups内の既存ポイントをすべて削除します。"
        parametersFormLayout.addRow("補助操作:", self.clearMarkupButton)

        self.instructionsLabel = qt.QLabel(
            "5つのランドマークを順番に配置してください:\n"
            "1) L1_ant (L1頭側終板 前縁)\n"
            "2) L1_post (L1頭側終板 後縁)\n"
            "3) S1_ant (S1頭側終板 前縁)\n"
            "4) S1_post (S1頭側終板 後縁)\n"
            "5) FH (両側大腿骨頭の中心)"
        )
        self.instructionsLabel.wordWrap = True
        parametersFormLayout.addRow("ランドマーク手順:", self.instructionsLabel)

        self.outputDirEdit = qt.QLineEdit()
        self.outputDirEdit.placeholderText = "出力先フォルダ（例: /path/to/dataset）"
        browseButton = qt.QPushButton("参照...")
        dirLayout = qt.QHBoxLayout()
        dirLayout.addWidget(self.outputDirEdit, 1)
        dirLayout.addWidget(browseButton)
        parametersFormLayout.addRow("出力先:", dirLayout)

        self.caseIdEdit = qt.QLineEdit()
        self.caseIdEdit.placeholderText = "例: case001"
        parametersFormLayout.addRow("ケースID (ファイル名プレフィックス):", self.caseIdEdit)

        self.exportButton = qt.QPushButton("エクスポート")
        self.exportButton.toolTip = "画像(.npy/.nrrd)とランドマーク(.json)を出力します。"
        parametersFormLayout.addRow(self.exportButton)

        self.statusLabel = qt.QLabel("")
        self.statusLabel.wordWrap = True
        parametersFormLayout.addRow(self.statusLabel)

        self.createMarkupButton.connect("clicked()", self.onCreateMarkup)
        self.clearMarkupButton.connect("clicked()", self.onClearMarkups)
        self.exportButton.connect("clicked()", self.onExport)
        browseButton.connect("clicked()", self.onBrowse)

        self.layout.addStretch(1)

        # Auto-numbering state
        self.counter = 1
        self.prefixEdit = qt.QLineEdit("case")
        self.overwriteCheck = qt.QCheckBox("既存があれば上書きする")
        self.overwriteCheck.checked = False
        autoLayout = qt.QHBoxLayout()
        autoLayout.addWidget(qt.QLabel("プレフィックス:"))
        autoLayout.addWidget(self.prefixEdit)
        autoLayout.addWidget(qt.QLabel("次番号:"))
        self.nextIdLabel = qt.QLabel(self._format_counter_preview())
        autoLayout.addWidget(self.nextIdLabel)
        parametersFormLayout.addRow("自動採番:", autoLayout)
        parametersFormLayout.addRow("", self.overwriteCheck)

    def onBrowse(self):
        directory = qt.QFileDialog.getExistingDirectory(
            slicer.util.mainWindow(), "出力先フォルダを選択"
        )
        if directory:
            self.outputDirEdit.text = directory

    def onCreateMarkup(self):
        fiducialNode = self._ensureMarkupNodeExists()
        self.markupSelector.setCurrentNode(fiducialNode)
        slicer.modules.markups.logic().StartPlaceMode(0)  # place a single point then exit place mode
        self.statusLabel.text = "1点だけ配置モードです。点を置いたら、次の点も同じボタンで再度配置してください。"

    def onClearMarkups(self):
        markupNode = self.markupSelector.currentNode()
        if markupNode is None:
            self.statusLabel.text = "クリアできるMarkupsが選択されていません。"
            return
        markupNode.RemoveAllControlPoints()
        self.statusLabel.text = "既存のポイントをクリアしました。"

    def onExport(self):
        volumeNode = self.volumeSelector.currentNode()
        markupNode = self.markupSelector.currentNode()
        outputDir = self.outputDirEdit.text.strip()
        manualCaseId = self.caseIdEdit.text.strip()

        if volumeNode is None:
            self.statusLabel.text = "エラー: Volumeが選択されていません。"
            return
        if markupNode is None:
            self.statusLabel.text = "エラー: Markupsが選択されていません。"
            return
        if not outputDir:
            self.statusLabel.text = "エラー: 出力先フォルダを指定してください。"
            return

        # Determine caseId via manual input or auto-numbering
        caseId = manualCaseId if manualCaseId else self._find_next_case_id(outputDir)
        if caseId is None:
            self.statusLabel.text = "エラー: 出力先で利用可能なIDを見つけられませんでした。"
            return

        try:
            result = self.logic.export_training_sample(
                volumeNode,
                markupNode,
                outputDir,
                caseId,
                overwrite=self.overwriteCheck.isChecked(),
            )
        except ValueError as exc:
            self.statusLabel.text = f"エラー: {exc}"
            return
        except Exception:
            logging.exception("Export failed")
            self.statusLabel.text = "エラー: エクスポートに失敗しました。詳細はPython Consoleを確認してください。"
            return

        self.statusLabel.text = (
            "エクスポート完了: "
            f"{os.path.basename(result['npy'])}, "
            f"{os.path.basename(result['json'])}"
        )
        if not manualCaseId:
            self.counter += 1
            self.nextIdLabel.setText(self._format_counter_preview())

    def _ensureMarkupNodeExists(self):
        current = self.markupSelector.currentNode()
        if current and current.IsA("vtkMRMLMarkupsFiducialNode"):
            return current
        fiducialNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode")
        displayNode = fiducialNode.GetDisplayNode()
        if displayNode:
            displayNode.SetSelectedColor(0.0, 0.7, 0.9)
            displayNode.SetGlyphScale(1.5)
        return fiducialNode

    def _format_counter_preview(self):
        return f"{self.prefixEdit.text().strip()}{self.counter:03d}"

    def _find_next_case_id(self, outputDir):
        prefix = self.prefixEdit.text().strip()
        if not prefix:
            prefix = "case"
        # try up to 9999 to find an unused ID (unless overwrite is allowed)
        for idx in range(self.counter, 10000):
            candidate = f"{prefix}{idx:03d}"
            npy = os.path.join(outputDir, f"{candidate}_image.npy")
            json_path = os.path.join(outputDir, f"{candidate}_landmarks.json")
            nrrd_path = os.path.join(outputDir, f"{candidate}_volume.nrrd")
            if self.overwriteCheck.isChecked():
                return candidate
            if not (os.path.exists(npy) or os.path.exists(json_path) or os.path.exists(nrrd_path)):
                return candidate
        return None


class SagittalMeasureTrainLogic(ScriptedLoadableModuleLogic):
    """Data export helpers."""

    REQUIRED_LABELS = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]

    def ensure_landmark_labels(self, markupNode):
        count = min(markupNode.GetNumberOfControlPoints(), len(self.REQUIRED_LABELS))
        for i in range(count):
            markupNode.SetNthControlPointLabel(i, self.REQUIRED_LABELS[i])

    def _ras_to_ijk(self, volumeNode, ras_point):
        ras_to_ijk = vtk.vtkMatrix4x4()
        volumeNode.GetRASToIJKMatrix(ras_to_ijk)
        ras_h = [ras_point[0], ras_point[1], ras_point[2], 1.0]
        ijk_h = ras_to_ijk.MultiplyPoint(ras_h)
        return ijk_h[:3]

    def _collect_landmarks_ijk(self, markupNode, volumeNode):
        self.ensure_landmark_labels(markupNode)
        if markupNode.GetNumberOfControlPoints() != len(self.REQUIRED_LABELS):
            raise ValueError("マークアップ点が5個ではありません。指定の順番で5点を配置してください。")

        coords = {}
        ras = [0.0, 0.0, 0.0]
        for i, label in enumerate(self.REQUIRED_LABELS):
            markupNode.GetNthControlPointPositionWorld(i, ras)
            ijk = self._ras_to_ijk(volumeNode, ras)
            coords[label] = {"i": float(ijk[0]), "j": float(ijk[1]), "k": float(ijk[2])}
        return coords

    def _volume_metadata(self, volumeNode):
        spacing = volumeNode.GetSpacing()
        ijk_to_ras = vtk.vtkMatrix4x4()
        volumeNode.GetIJKToRASMatrix(ijk_to_ras)
        direction = [
            [ijk_to_ras.GetElement(r, c) for c in range(3)]
            for r in range(3)
        ]
        origin = [ijk_to_ras.GetElement(r, 3) for r in range(3)]
        return {
            "spacing": list(spacing),
            "ijk_to_ras": direction,
            "origin_ras": origin,
        }

    def _check_overwrite(self, outputDir, caseId, overwrite):
        npy_path = os.path.join(outputDir, f"{caseId}_image.npy")
        json_path = os.path.join(outputDir, f"{caseId}_landmarks.json")
        nrrd_path = os.path.join(outputDir, f"{caseId}_volume.nrrd")
        exists = [p for p in (npy_path, json_path, nrrd_path) if os.path.exists(p)]
        if exists and not overwrite:
            raise ValueError(f"既に存在するファイルがあります: {', '.join(os.path.basename(p) for p in exists)}")
        return npy_path, json_path, nrrd_path

    def export_training_sample(self, volumeNode, markupNode, outputDir, caseId, overwrite=False):
        os.makedirs(outputDir, exist_ok=True)
        npy_path, json_path, nrrd_path = self._check_overwrite(outputDir, caseId, overwrite)

        # Export image array as .npy (full volume). For typical X-ray this will be 2D (1 slice).
        image_array = slicer.util.arrayFromVolume(volumeNode)
        np.save(npy_path, image_array)

        # Save the source volume as NRRD for reproducibility.
        slicer.util.saveNode(volumeNode, nrrd_path)

        # Collect landmark coordinates in IJK (pixel) space.
        landmarks_ijk = self._collect_landmarks_ijk(markupNode, volumeNode)
        metadata = self._volume_metadata(volumeNode)

        with open(json_path, "w", encoding="utf-8") as fp:
            json.dump(
                {
                    "case_id": caseId,
                    "landmarks_ijk": landmarks_ijk,
                    "metadata": metadata,
                    "image_shape": list(image_array.shape),
                },
                fp,
                ensure_ascii=False,
                indent=2,
            )

        return {"npy": npy_path, "json": json_path, "nrrd": nrrd_path}


class SagittalMeasureTrainTest(ScriptedLoadableModuleTest):
    """Placeholder tests."""

    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_placeholder()

    def test_placeholder(self):
        self.assertTrue(True)
