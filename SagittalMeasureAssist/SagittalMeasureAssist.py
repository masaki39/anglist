"""
SagittalMeasureAssist
-----------------------
Usage:
- (Optional) Load a lateral spine x-ray volume in Slicer.
- Open this module, choose the volume (optional), and create/select a Markups Fiducial.
- Place 5 points in order (top to bottom): L1_ant, L1_post, S1_ant, S1_post, FH.
- Click "Update Measurements" to compute PI, PT, SS, and LL.
- (Optional) Export a training sample (.npy/.nrrd/.json) with the same landmarks and angles.

This module is a manual landmark-driven scaffold for future AI-assisted keypoint
suggestion. Geometry calculations are isolated in the Logic class so automated
detectors can be plugged in later.
"""

import json
import logging
import math
import os

import qt
import ctk
import slicer
import vtk
import numpy as np
from slicer.ScriptedLoadableModule import ScriptedLoadableModule, ScriptedLoadableModuleWidget, ScriptedLoadableModuleLogic, ScriptedLoadableModuleTest

import angles


class SagittalMeasureAssist(ScriptedLoadableModule):
    """Main module class required by Slicer."""

    def __init__(self, parent=None):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "Sagittal Measure Assist"
        self.parent.categories = ["Spine"]
        self.parent.dependencies = []
        self.parent.contributors = ["Generated by masaki39"]
        self.parent.helpText = (
            "Manually place 5 landmarks on a lateral x-ray (FH, S1_ant, S1_post, "
            "L1_ant, L1_post) and compute PI, PT, SS, and LL. Designed as a base "
            "for future AI-assisted keypoint proposals."
        )
        self.parent.acknowledgementText = "Developed as a scaffold for sagittal parameter measurement."


class SagittalMeasureAssistWidget(ScriptedLoadableModuleWidget):
    """Widget setup and interactions."""

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        self.logic = SagittalMeasureAssistLogic()

        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "計測"
        self.layout.addWidget(parametersCollapsibleButton)

        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        self.volumeSelector = slicer.qMRMLNodeComboBox()
        self.volumeSelector.nodeTypes = ["vtkMRMLScalarVolumeNode"]
        self.volumeSelector.selectNodeUponCreation = True
        self.volumeSelector.addEnabled = False
        self.volumeSelector.removeEnabled = False
        self.volumeSelector.noneEnabled = True
        self.volumeSelector.showHidden = False
        self.volumeSelector.showChildNodeTypes = False
        self.volumeSelector.setMRMLScene(slicer.mrmlScene)
        self.volumeSelector.setToolTip("対象の側面X線Volumeを選択します（計測のみなら未選択でも可）。")
        parametersFormLayout.addRow("Volume:", self.volumeSelector)

        self.markupSelector = slicer.qMRMLNodeComboBox()
        self.markupSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupSelector.selectNodeUponCreation = True
        self.markupSelector.addEnabled = False
        self.markupSelector.removeEnabled = False
        self.markupSelector.noneEnabled = True
        self.markupSelector.showHidden = False
        self.markupSelector.showChildNodeTypes = False
        self.markupSelector.setMRMLScene(slicer.mrmlScene)
        self.markupSelector.setToolTip("Select or create a Markups Fiducial node for the 5 landmarks.")
        parametersFormLayout.addRow("Markups:", self.markupSelector)

        self.createMarkupButton = qt.QPushButton("新規作成 / 1点追加")
        self.createMarkupButton.toolTip = "Markupsを作成し、1点だけ配置モードに入ります。次の点もこのボタンで追加してください。"
        parametersFormLayout.addRow("Markupsを自動作成:", self.createMarkupButton)

        self.clearMarkupButton = qt.QPushButton("配置点をクリア")
        self.clearMarkupButton.toolTip = "選択中のMarkups内の既存ポイントをすべて削除します。"
        parametersFormLayout.addRow("補助操作:", self.clearMarkupButton)

        self.flipXAxisCheckBox = qt.QCheckBox("左右反転を補正（x軸反転）")
        self.flipXAxisCheckBox.toolTip = "画像が左右逆（前方が左向き）で表示されている場合にチェック。計算時にx座標の符号を反転します。"
        parametersFormLayout.addRow("左右反転補正:", self.flipXAxisCheckBox)

        self.instructionsLabel = qt.QLabel(
            "5つのランドマークを順番に配置してください:\n"
            "1) L1_ant (L1頭側終板 前縁)\n"
            "2) L1_post (L1頭側終板 後縁)\n"
            "3) S1_ant (S1頭側終板 前縁)\n"
            "4) S1_post (S1頭側終板 後縁)\n"
            "5) FH (両側大腿骨頭の中心)"
        )
        self.instructionsLabel.wordWrap = True
        parametersFormLayout.addRow("ランドマーク手順:", self.instructionsLabel)

        self.updateButton = qt.QPushButton("計測を更新")
        self.updateButton.toolTip = "Compute PI, PT, SS, and LL from the current 5 landmarks."
        self.updateButton.enabled = True
        parametersFormLayout.addRow(self.updateButton)

        self.resultsTable = qt.QTableWidget()
        self.resultsTable.setRowCount(4)
        self.resultsTable.setColumnCount(2)
        self.resultsTable.setHorizontalHeaderLabels(["Parameter", "Value (deg)"])
        self.resultsTable.verticalHeader().hide()
        self.resultsTable.horizontalHeader().setStretchLastSection(True)
        params = ["PI", "PT", "SS", "LL"]
        for i, name in enumerate(params):
            nameItem = qt.QTableWidgetItem(name)
            nameItem.setFlags(qt.Qt.ItemIsEnabled)
            self.resultsTable.setItem(i, 0, nameItem)
            valueItem = qt.QTableWidgetItem("--")
            valueItem.setFlags(qt.Qt.ItemIsEnabled)
            self.resultsTable.setItem(i, 1, valueItem)
        parametersFormLayout.addRow("計測結果:", self.resultsTable)

        self.statusLabel = qt.QLabel("")
        self.statusLabel.wordWrap = True
        parametersFormLayout.addRow(self.statusLabel)

        # --- Export section ---
        exportCollapsible = ctk.ctkCollapsibleButton()
        exportCollapsible.text = "エクスポート（学習データ）"
        self.layout.addWidget(exportCollapsible)
        exportForm = qt.QFormLayout(exportCollapsible)

        self.outputDirEdit = qt.QLineEdit()
        self.outputDirEdit.placeholderText = "出力先フォルダ（例: /path/to/dataset）"
        browseButton = qt.QPushButton("参照...")
        dirLayout = qt.QHBoxLayout()
        dirLayout.addWidget(self.outputDirEdit, 1)
        dirLayout.addWidget(browseButton)
        exportForm.addRow("出力先:", dirLayout)

        self.caseIdEdit = qt.QLineEdit()
        self.caseIdEdit.placeholderText = "手入力する場合はこちら（例: case001）"
        exportForm.addRow("ケースID:", self.caseIdEdit)

        self.counter = 1
        self.prefixEdit = qt.QLineEdit("case")
        self.overwriteCheck = qt.QCheckBox("既存があれば上書きする")
        self.overwriteCheck.checked = False
        self.nextIdLabel = qt.QLabel(self._format_counter_preview())
        autoLayout = qt.QHBoxLayout()
        autoLayout.addWidget(qt.QLabel("プレフィックス:"))
        autoLayout.addWidget(self.prefixEdit)
        autoLayout.addWidget(qt.QLabel("次番号:"))
        autoLayout.addWidget(self.nextIdLabel)
        exportForm.addRow("自動採番:", autoLayout)
        exportForm.addRow("", self.overwriteCheck)

        self.exportButton = qt.QPushButton("エクスポート")
        self.exportButton.toolTip = ".npy/.nrrd とランドマークJSON(角度付き)を書き出します。"
        exportForm.addRow(self.exportButton)

        self.exportStatusLabel = qt.QLabel("")
        self.exportStatusLabel.wordWrap = True
        exportForm.addRow(self.exportStatusLabel)

        # Signals
        self.createMarkupButton.connect("clicked()", self.onCreateMarkup)
        self.clearMarkupButton.connect("clicked()", self.onClearMarkups)
        self.updateButton.connect("clicked()", self.onUpdateMeasurements)
        self.exportButton.connect("clicked()", self.onExport)
        browseButton.connect("clicked()", self.onBrowse)
        self.prefixEdit.textChanged.connect(lambda *_: self.nextIdLabel.setText(self._format_counter_preview()))

        self.layout.addStretch(1)

    def onCreateMarkup(self):
        fiducialNode = self._ensureMarkupNodeExists()
        self.markupSelector.setCurrentNode(fiducialNode)
        slicer.modules.markups.logic().StartPlaceMode(0)  # place a single point then exit place mode
        self.statusLabel.text = "1点だけ配置モードです。点を置いたら、次の点も同じボタンで再度配置してください。"

    def onClearMarkups(self):
        markupNode = self.markupSelector.currentNode()
        if markupNode is None:
            self.statusLabel.text = "クリアできるMarkupsが選択されていません。"
            return
        markupNode.RemoveAllControlPoints()
        self.statusLabel.text = "既存のポイントをクリアしました。"

    def onUpdateMeasurements(self):
        markupNode = self.markupSelector.currentNode()
        if markupNode is None:
            self.statusLabel.text = "エラー: Markupsが選択されていません。"
            return
        self._assignLandmarkLabels(markupNode)
        if markupNode.GetNumberOfFiducials() != 5:
            self.statusLabel.text = "エラー: マークアップ点が5個ではありません。指定の順番で5点を配置してください。"
            return

        pointLabels = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]
        points = {}
        coordsRAS = [0.0, 0.0, 0.0]
        for idx, label in enumerate(pointLabels):
            markupNode.GetNthFiducialPosition(idx, coordsRAS)
            x = coordsRAS[0]
            y = coordsRAS[1]
            if self.flipXAxisCheckBox.isChecked():
                x = -x
            points[label] = (x, y)

        try:
            angles = self.logic.compute_angles_from_points(points)
        except ValueError as exc:
            self.statusLabel.text = f"エラー: {exc}"
            return

        self._updateResultsTable(angles)
        self.statusLabel.text = "計測を更新しました。"

    def onBrowse(self):
        directory = qt.QFileDialog.getExistingDirectory(
            slicer.util.mainWindow(), "出力先フォルダを選択"
        )
        if directory:
            self.outputDirEdit.text = directory

    def onExport(self):
        volumeNode = self.volumeSelector.currentNode()
        markupNode = self.markupSelector.currentNode()
        outputDir = self.outputDirEdit.text.strip()
        manualCaseId = self.caseIdEdit.text.strip()

        if volumeNode is None:
            self.exportStatusLabel.text = "エラー: Volumeが選択されていません。"
            return
        if markupNode is None:
            self.exportStatusLabel.text = "エラー: Markupsが選択されていません。"
            return
        if not outputDir:
            self.exportStatusLabel.text = "エラー: 出力先フォルダを指定してください。"
            return

        caseId = manualCaseId if manualCaseId else self._find_next_case_id(outputDir)
        if caseId is None:
            self.exportStatusLabel.text = "エラー: 利用可能なケースIDを見つけられませんでした。"
            return

        try:
            result = self.logic.export_training_sample(
                volumeNode=volumeNode,
                markupNode=markupNode,
                outputDir=outputDir,
                caseId=caseId,
                flip_x_axis=self.flipXAxisCheckBox.isChecked(),
                overwrite=self.overwriteCheck.isChecked(),
            )
        except ValueError as exc:
            self.exportStatusLabel.text = f"エラー: {exc}"
            return
        except Exception:
            logging.exception("Export failed")
            self.exportStatusLabel.text = "エラー: エクスポートに失敗しました。詳細はPython Consoleを確認してください。"
            return

        self.exportStatusLabel.text = (
            "エクスポート完了: "
            f"{os.path.basename(result['npy'])}, "
            f"{os.path.basename(result['json'])}"
        )
        if not manualCaseId:
            self.counter += 1
            self.nextIdLabel.setText(self._format_counter_preview())

    def _ensureMarkupNodeExists(self):
        current = self.markupSelector.currentNode()
        if current and current.IsA("vtkMRMLMarkupsFiducialNode"):
            return current
        fiducialNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode")
        displayNode = fiducialNode.GetDisplayNode()
        if displayNode:
            displayNode.SetSelectedColor(1.0, 0.4, 0.0)
            displayNode.SetGlyphScale(1.5)
        return fiducialNode

    def _assignLandmarkLabels(self, markupNode):
        """Rename existing points in order so labels match the required landmarks."""
        required_labels = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]
        count = min(markupNode.GetNumberOfFiducials(), len(required_labels))
        for i in range(count):
            markupNode.SetNthControlPointLabel(i, required_labels[i])

    def _updateResultsTable(self, anglesDict):
        params = ["PI", "PT", "SS", "LL"]
        for i, name in enumerate(params):
            value = anglesDict.get(name, float("nan"))
            if math.isnan(value):
                text = "--"
            else:
                text = f"{value:.1f}°"
            self.resultsTable.item(i, 1).setText(text)

    def _format_counter_preview(self):
        prefix = self.prefixEdit.text().strip() or "case"
        return f"{prefix}{self.counter:03d}"

    def _find_next_case_id(self, outputDir):
        prefix = self.prefixEdit.text().strip() or "case"
        for idx in range(self.counter, 10000):
            candidate = f"{prefix}{idx:03d}"
            npy = os.path.join(outputDir, f"{candidate}_image.npy")
            json_path = os.path.join(outputDir, f"{candidate}_landmarks.json")
            nrrd_path = os.path.join(outputDir, f"{candidate}_volume.nrrd")
            if self.overwriteCheck.isChecked():
                return candidate
            if not (os.path.exists(npy) or os.path.exists(json_path) or os.path.exists(nrrd_path)):
                return candidate
        return None


class SagittalMeasureAssistLogic(ScriptedLoadableModuleLogic):
    """Geometry computations for sagittal parameters."""

    REQUIRED_KEYS = ["FH", "S1_ant", "S1_post", "L1_ant", "L1_post"]
    REQUIRED_LABELS_ORDERED = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]

    def compute_angles_from_points(self, points):
        """
        Compute PI, PT, SS, and LL from landmark points.

        Args:
            points (dict): Mapping of landmark names to (x, y) tuples.
        Returns:
            dict: {"PI": deg, "PT": deg, "SS": deg, "LL": deg}
        """
        missing = [k for k in self.REQUIRED_KEYS if k not in points]
        if missing:
            raise ValueError(f"Missing points: {', '.join(missing)}")

        FH = points["FH"]
        S1_ant = points["S1_ant"]
        S1_post = points["S1_post"]
        L1_ant = points["L1_ant"]
        L1_post = points["L1_post"]

        v_S1 = angles.vector_from_points(S1_ant, S1_post)
        v_L1 = angles.vector_from_points(L1_ant, L1_post)
        S1_mid = ((S1_ant[0] + S1_post[0]) / 2.0, (S1_ant[1] + S1_post[1]) / 2.0)
        v_pelvis = angles.vector_from_points(FH, S1_mid)

        SS = angles.signed_slope_angle_deg(v_S1)
        PT = angles.signed_vertical_angle_deg(v_pelvis)
        LL = angles.lumbosacral_lordosis_deg(v_L1, v_S1)
        PI_modified = angles.pelvic_incidence_deg(v_pelvis, v_S1)

        return {"PI": PI_modified, "PT": PT, "SS": SS, "LL": LL}

    def _check_overwrite(self, outputDir, caseId, overwrite):
        npy_path = os.path.join(outputDir, f"{caseId}_image.npy")
        json_path = os.path.join(outputDir, f"{caseId}_landmarks.json")
        nrrd_path = os.path.join(outputDir, f"{caseId}_volume.nrrd")
        exists = [p for p in (npy_path, json_path, nrrd_path) if os.path.exists(p)]
        if exists and not overwrite:
            raise ValueError(f"既に存在するファイルがあります: {', '.join(os.path.basename(p) for p in exists)}")
        return npy_path, json_path, nrrd_path

    def _ras_to_ijk(self, volumeNode, ras_point):
        ras_to_ijk = vtk.vtkMatrix4x4()
        volumeNode.GetRASToIJKMatrix(ras_to_ijk)
        ras_h = [ras_point[0], ras_point[1], ras_point[2], 1.0]
        ijk_h = ras_to_ijk.MultiplyPoint(ras_h)
        return ijk_h[:3]

    def _collect_landmarks_ijk(self, markupNode, volumeNode):
        if markupNode.GetNumberOfControlPoints() != len(self.REQUIRED_LABELS_ORDERED):
            raise ValueError("マークアップ点が5個ではありません。指定の順番で5点を配置してください。")
        coords = {}
        ras = [0.0, 0.0, 0.0]
        for i, label in enumerate(self.REQUIRED_LABELS_ORDERED):
            markupNode.SetNthControlPointLabel(i, label)
            markupNode.GetNthControlPointPositionWorld(i, ras)
            ijk = self._ras_to_ijk(volumeNode, ras)
            coords[label] = {"i": float(ijk[0]), "j": float(ijk[1]), "k": float(ijk[2])}
        return coords

    def _collect_landmarks_ras_2d(self, markupNode, flip_x_axis=False):
        if markupNode.GetNumberOfControlPoints() != len(self.REQUIRED_LABELS_ORDERED):
            raise ValueError("マークアップ点が5個ではありません。指定の順番で5点を配置してください。")
        points = {}
        coordsRAS = [0.0, 0.0, 0.0]
        for idx, label in enumerate(self.REQUIRED_LABELS_ORDERED):
            markupNode.SetNthControlPointLabel(idx, label)
            markupNode.GetNthFiducialPosition(idx, coordsRAS)
            x = -coordsRAS[0] if flip_x_axis else coordsRAS[0]
            y = coordsRAS[1]
            points[label] = (x, y)
        return points

    def _volume_metadata(self, volumeNode):
        spacing = volumeNode.GetSpacing()
        ijk_to_ras = vtk.vtkMatrix4x4()
        volumeNode.GetIJKToRASMatrix(ijk_to_ras)
        direction = [[ijk_to_ras.GetElement(r, c) for c in range(3)] for r in range(3)]
        origin = [ijk_to_ras.GetElement(r, 3) for r in range(3)]
        return {"spacing": list(spacing), "ijk_to_ras": direction, "origin_ras": origin}

    def export_training_sample(self, volumeNode, markupNode, outputDir, caseId, flip_x_axis=False, overwrite=False):
        if markupNode.GetNumberOfControlPoints() != len(self.REQUIRED_LABELS_ORDERED):
            raise ValueError("マークアップ点が5個ではありません。指定の順番で5点を配置してください。")

        os.makedirs(outputDir, exist_ok=True)
        npy_path, json_path, nrrd_path = self._check_overwrite(outputDir, caseId, overwrite)

        # Export image array as .npy (full volume). For typical X-ray this will be 2D (1 slice).
        image_array = slicer.util.arrayFromVolume(volumeNode)
        np.save(npy_path, image_array)

        # Save the source volume as NRRD for reproducibility.
        slicer.util.saveNode(volumeNode, nrrd_path)

        # Collect landmarks and angles.
        landmarks_ijk = self._collect_landmarks_ijk(markupNode, volumeNode)
        metadata = self._volume_metadata(volumeNode)
        points_ras_2d = self._collect_landmarks_ras_2d(markupNode, flip_x_axis=flip_x_axis)
        angles_deg = self.compute_angles_from_points(points_ras_2d)

        with open(json_path, "w", encoding="utf-8") as fp:
            json.dump(
                {
                    "case_id": caseId,
                    "landmarks_ijk": landmarks_ijk,
                    "metadata": metadata,
                    "image_shape": list(image_array.shape),
                    "angles_deg": angles_deg,
                    "flip_x_axis": bool(flip_x_axis),
                },
                fp,
                ensure_ascii=False,
                indent=2,
            )

        return {"npy": npy_path, "json": json_path, "nrrd": nrrd_path}


class SagittalMeasureAssistTest(ScriptedLoadableModuleTest):
    """Basic tests for the logic class."""

    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_compute_angles_simple_geometry()

    def test_compute_angles_simple_geometry(self):
        """
        Use a simple synthetic configuration to validate angles.
        """
        logic = SagittalMeasureAssistLogic()
        points = {
            "FH": (0.5, 2.0),
            "S1_ant": (0.0, 0.0),
            "S1_post": (1.0, 1.0),
            "L1_ant": (0.0, 1.0),
            "L1_post": (1.0, 2.0),
        }
        angles = logic.compute_angles_from_points(points)

        self.assertTrue(abs(angles["SS"] + 45.0) < 0.5)  # SS expected -45 (signed)
        self.assertTrue(abs(angles["LL"] - 0.0) < 0.5)
        self.assertTrue(abs(angles["PT"] - 0.0) < 0.5)
        self.assertTrue(abs(angles["PI"] - 45.0) < 0.5)
