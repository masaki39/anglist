"""
SagittalMeasureAssist
-----------------------
Usage:
- (Optional) Load a lateral spine x-ray volume in Slicer.
- Open this module, choose the volume (optional), and create/select a Markups Fiducial.
- Place 5 points in order (top to bottom): L1_ant, L1_post, S1_ant, S1_post, FH.
- Click "Update Measurements" to compute PI, PT, SS, and LL.

This module is a manual landmark-driven scaffold for future AI-assisted keypoint
suggestion. Geometry calculations are isolated in the Logic class so automated
detectors can be plugged in later.
"""

import logging
import math

import qt
import ctk
import slicer
from slicer.ScriptedLoadableModule import ScriptedLoadableModule, ScriptedLoadableModuleWidget, ScriptedLoadableModuleLogic, ScriptedLoadableModuleTest

import angles


class SagittalMeasureAssist(ScriptedLoadableModule):
    """Main module class required by Slicer."""

    def __init__(self, parent=None):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "Sagittal Measure Assist"
        self.parent.categories = ["Spine"]
        self.parent.dependencies = []
        self.parent.contributors = ["Generated by assistant"]
        self.parent.helpText = (
            "Manually place 5 landmarks on a lateral x-ray (FH, S1_ant, S1_post, "
            "L1_ant, L1_post) and compute PI, PT, SS, and LL. Designed as a base "
            "for future AI-assisted keypoint proposals."
        )
        self.parent.acknowledgementText = "Developed as a scaffold for sagittal parameter measurement."


class SagittalMeasureAssistWidget(ScriptedLoadableModuleWidget):
    """Widget setup and interactions."""

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        self.logic = SagittalMeasureAssistLogic()

        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Parameters"
        self.layout.addWidget(parametersCollapsibleButton)

        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        self.volumeSelector = slicer.qMRMLNodeComboBox()
        self.volumeSelector.nodeTypes = ["vtkMRMLScalarVolumeNode"]
        self.volumeSelector.selectNodeUponCreation = True
        self.volumeSelector.addEnabled = False
        self.volumeSelector.removeEnabled = False
        self.volumeSelector.noneEnabled = True
        self.volumeSelector.showHidden = False
        self.volumeSelector.showChildNodeTypes = False
        self.volumeSelector.setMRMLScene(slicer.mrmlScene)
        self.volumeSelector.setToolTip("Select the lateral x-ray volume.")
        parametersFormLayout.addRow("対象の側面X線Volumeを選択:", self.volumeSelector)

        self.markupSelector = slicer.qMRMLNodeComboBox()
        self.markupSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupSelector.selectNodeUponCreation = True
        self.markupSelector.addEnabled = False
        self.markupSelector.removeEnabled = False
        self.markupSelector.noneEnabled = True
        self.markupSelector.showHidden = False
        self.markupSelector.showChildNodeTypes = False
        self.markupSelector.setMRMLScene(slicer.mrmlScene)
        self.markupSelector.setToolTip("Select or create a Markups Fiducial node for the 5 landmarks.")
        parametersFormLayout.addRow("Markups (Fiducial) ノード:", self.markupSelector)

        self.createMarkupButton = qt.QPushButton("新規作成 / 1点追加")
        self.createMarkupButton.toolTip = "Markupsを作成し、1点だけ配置モードに入ります。次の点もこのボタンで追加してください。"
        parametersFormLayout.addRow("Markupsを自動作成:", self.createMarkupButton)

        self.clearMarkupButton = qt.QPushButton("配置点をクリア")
        self.clearMarkupButton.toolTip = "選択中のMarkups内の既存ポイントをすべて削除します。"
        parametersFormLayout.addRow("補助操作:", self.clearMarkupButton)

        self.flipXAxisCheckBox = qt.QCheckBox("左右反転を補正（x軸反転）")
        self.flipXAxisCheckBox.toolTip = "画像が左右逆（前方が左向き）で表示されている場合にチェック。計算時にx座標の符号を反転します。"
        parametersFormLayout.addRow("左右反転補正:", self.flipXAxisCheckBox)

        self.instructionsLabel = qt.QLabel(
            "5つのランドマークを順番に配置してください:\n"
            "1) L1_ant (L1頭側終板 前縁)\n"
            "2) L1_post (L1頭側終板 後縁)\n"
            "3) S1_ant (S1頭側終板 前縁)\n"
            "4) S1_post (S1頭側終板 後縁)\n"
            "5) FH (両側大腿骨頭の中心)"
        )
        self.instructionsLabel.wordWrap = True
        parametersFormLayout.addRow("ランドマーク手順:", self.instructionsLabel)

        self.updateButton = qt.QPushButton("計測を更新")
        self.updateButton.toolTip = "Compute PI, PT, SS, and LL from the current 5 landmarks."
        self.updateButton.enabled = True
        parametersFormLayout.addRow(self.updateButton)

        self.resultsTable = qt.QTableWidget()
        self.resultsTable.setRowCount(4)
        self.resultsTable.setColumnCount(2)
        self.resultsTable.setHorizontalHeaderLabels(["Parameter", "Value (deg)"])
        self.resultsTable.verticalHeader().hide()
        self.resultsTable.horizontalHeader().setStretchLastSection(True)
        params = ["PI", "PT", "SS", "LL"]
        for i, name in enumerate(params):
            nameItem = qt.QTableWidgetItem(name)
            nameItem.setFlags(qt.Qt.ItemIsEnabled)
            self.resultsTable.setItem(i, 0, nameItem)
            valueItem = qt.QTableWidgetItem("--")
            valueItem.setFlags(qt.Qt.ItemIsEnabled)
            self.resultsTable.setItem(i, 1, valueItem)
        parametersFormLayout.addRow("計測結果:", self.resultsTable)

        self.statusLabel = qt.QLabel("")
        self.statusLabel.wordWrap = True
        parametersFormLayout.addRow(self.statusLabel)

        self.createMarkupButton.connect("clicked()", self.onCreateMarkup)
        self.clearMarkupButton.connect("clicked()", self.onClearMarkups)
        self.updateButton.connect("clicked()", self.onUpdateMeasurements)

        self.layout.addStretch(1)

    def onCreateMarkup(self):
        fiducialNode = self._ensureMarkupNodeExists()
        self.markupSelector.setCurrentNode(fiducialNode)
        slicer.modules.markups.logic().StartPlaceMode(0)  # place a single point then exit place mode
        self.statusLabel.text = "1点だけ配置モードです。点を置いたら、次の点も同じボタンで再度配置してください。"

    def onClearMarkups(self):
        markupNode = self.markupSelector.currentNode()
        if markupNode is None:
            self.statusLabel.text = "クリアできるMarkupsが選択されていません。"
            return
        markupNode.RemoveAllControlPoints()
        self.statusLabel.text = "既存のポイントをクリアしました。"

    def onUpdateMeasurements(self):
        markupNode = self.markupSelector.currentNode()
        if markupNode is None:
            self.statusLabel.text = "エラー: Markupsが選択されていません。"
            return
        self._assignLandmarkLabels(markupNode)
        if markupNode.GetNumberOfFiducials() != 5:
            self.statusLabel.text = "エラー: マークアップ点が5個ではありません。指定の順番で5点を配置してください。"
            return

        pointLabels = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]
        points = {}
        coordsRAS = [0.0, 0.0, 0.0]
        for idx, label in enumerate(pointLabels):
            markupNode.GetNthFiducialPosition(idx, coordsRAS)
            x = coordsRAS[0]
            y = coordsRAS[1]
            if self.flipXAxisCheckBox.isChecked():
                x = -x
            points[label] = (x, y)

        try:
            angles = self.logic.compute_angles_from_points(points)
        except ValueError as exc:
            self.statusLabel.text = f"エラー: {exc}"
            return

        self._updateResultsTable(angles)
        self.statusLabel.text = "計測を更新しました。"

    def _ensureMarkupNodeExists(self):
        current = self.markupSelector.currentNode()
        if current and current.IsA("vtkMRMLMarkupsFiducialNode"):
            return current
        fiducialNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode")
        displayNode = fiducialNode.GetDisplayNode()
        if displayNode:
            displayNode.SetSelectedColor(1.0, 0.4, 0.0)
            displayNode.SetGlyphScale(1.5)
        return fiducialNode

    def _assignLandmarkLabels(self, markupNode):
        """Rename existing points in order so labels match the required landmarks."""
        required_labels = ["L1_ant", "L1_post", "S1_ant", "S1_post", "FH"]
        count = min(markupNode.GetNumberOfFiducials(), len(required_labels))
        for i in range(count):
            markupNode.SetNthControlPointLabel(i, required_labels[i])

    def _updateResultsTable(self, anglesDict):
        params = ["PI", "PT", "SS", "LL"]
        for i, name in enumerate(params):
            value = anglesDict.get(name, float("nan"))
            if math.isnan(value):
                text = "--"
            else:
                text = f"{value:.1f}°"
            self.resultsTable.item(i, 1).setText(text)


class SagittalMeasureAssistLogic(ScriptedLoadableModuleLogic):
    """Geometry computations for sagittal parameters."""

    REQUIRED_KEYS = ["FH", "S1_ant", "S1_post", "L1_ant", "L1_post"]

    def compute_angles_from_points(self, points):
        """
        Compute PI, PT, SS, and LL from landmark points.

        Args:
            points (dict): Mapping of landmark names to (x, y) tuples.
        Returns:
            dict: {"PI": deg, "PT": deg, "SS": deg, "LL": deg}
        """
        missing = [k for k in self.REQUIRED_KEYS if k not in points]
        if missing:
            raise ValueError(f"Missing points: {', '.join(missing)}")

        FH = points["FH"]
        S1_ant = points["S1_ant"]
        S1_post = points["S1_post"]
        L1_ant = points["L1_ant"]
        L1_post = points["L1_post"]

        v_S1 = angles.vector_from_points(S1_ant, S1_post)
        v_L1 = angles.vector_from_points(L1_ant, L1_post)
        S1_mid = ((S1_ant[0] + S1_post[0]) / 2.0, (S1_ant[1] + S1_post[1]) / 2.0)
        v_pelvis = angles.vector_from_points(FH, S1_mid)

        SS = angles.signed_slope_angle_deg(v_S1)
        PT = angles.signed_vertical_angle_deg(v_pelvis)
        LL = angles.lumbosacral_lordosis_deg(v_L1, v_S1)
        PI_modified = angles.pelvic_incidence_deg(v_pelvis, v_S1)

        return {"PI": PI_modified, "PT": PT, "SS": SS, "LL": LL}


class SagittalMeasureAssistTest(ScriptedLoadableModuleTest):
    """Basic tests for the logic class."""

    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_compute_angles_simple_geometry()

    def test_compute_angles_simple_geometry(self):
        """
        Use a simple synthetic configuration to validate angles.
        """
        logic = SagittalMeasureAssistLogic()
        points = {
            "FH": (0.5, 2.0),
            "S1_ant": (0.0, 0.0),
            "S1_post": (1.0, 1.0),
            "L1_ant": (0.0, 1.0),
            "L1_post": (1.0, 2.0),
        }
        angles = logic.compute_angles_from_points(points)

        self.assertTrue(abs(angles["SS"] + 45.0) < 0.5)  # SS expected -45 (signed)
        self.assertTrue(abs(angles["LL"] - 0.0) < 0.5)
        self.assertTrue(abs(angles["PT"] - 0.0) < 0.5)
        self.assertTrue(abs(angles["PI"] - 45.0) < 0.5)
